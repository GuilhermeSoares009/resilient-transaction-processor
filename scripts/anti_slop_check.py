#!/usr/bin/env python3
from __future__ import annotations

import re
import sys
from pathlib import Path

AI_PATTERNS = [
    (re.compile(r"(?i)\blorem ipsum\b"), "placeholder text"),
    (
        re.compile(r"(?i)\bas an ai\b|\bai language model\b|\blanguage model\b"),
        "ai disclaimer",
    ),
    (re.compile(r"(?i)\bgenerated by\b"), "ai disclaimer"),
    (re.compile(r"(?i)\bchatgpt\b|\bcopilot\b|\bclaude\b"), "ai tool mention"),
    (
        re.compile(
            r"(?i)\bto be filled\b|\binsert here\b|\breplace this\b|\bplaceholder\b"
        ),
        "placeholder instruction",
    ),
]

TODO_PATTERN = re.compile(r"(?i)\b(todo|fixme|tbd|wip)\b")
ALLOWED_TODO = re.compile(r"(?i)\b(todo|fixme)\s*\((#\d+|[A-Z]+-\d+)\)\b")


def is_binary(data: bytes) -> bool:
    return b"\x00" in data


def check_file(path: Path) -> list[str]:
    if path.name == "anti_slop_check.py":
        return []
    try:
        data = path.read_bytes()
    except OSError:
        return []

    if is_binary(data):
        return []

    try:
        text = data.decode("utf-8")
    except UnicodeDecodeError:
        text = data.decode("utf-8", errors="ignore")

    issues: list[str] = []
    for idx, line in enumerate(text.splitlines(), start=1):
        for pattern, label in AI_PATTERNS:
            if pattern.search(line):
                issues.append(f"{path}:{idx}: {label}")
        if TODO_PATTERN.search(line) and not ALLOWED_TODO.search(line):
            issues.append(f"{path}:{idx}: TODO/FIXME/TBD/WIP without issue reference")
    return issues


def main(argv: list[str]) -> int:
    if not argv:
        return 0

    all_issues: list[str] = []
    for raw in argv:
        path = Path(raw)
        if not path.exists() or path.is_dir():
            continue
        all_issues.extend(check_file(path))

    if not all_issues:
        return 0

    print("anti-slop check failed:")
    for issue in all_issues:
        print(f"- {issue}")
    return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
